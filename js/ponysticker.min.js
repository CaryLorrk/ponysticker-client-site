var PonyModule = (function () {
    var m = {};
    m.isPositiveInteger = isPositiveInteger;
    m.resolveParamFactory = resolveParamFactory;
    m.resolveIntParamFactory = resolveIntParamFactory;
    m.objSize = objSize;
    m.objIntersection = objIntersection;
    m.objUnionInPlace = objUnionInPlace;

    window.onload = function() {
        m.saveData = (function () {
            var a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            return function (data, fileName) {
                console.log(data);
                var json = JSON.stringify(data),
                blob = new Blob([json], {type: 'octet/stream'}),
                url = window.URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                window.URL.revokeObjectURL(url);
            };
        }());
    };

    init();

    return m;

    function objIntersection(obj1, obj2) {
        var obj = {};
        for(var key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                if (obj2.hasOwnProperty(key)) {
                    obj[key] = true;
                }
            }
        }
        return obj;
    }

    function objUnionInPlace(obj1, obj2) {
        for (var key in obj2) {
            if (obj2.hasOwnProperty(key)) {
                obj1[key] = true;
            }
        }
        return obj1;
    }



    function resolveParamFactory(param) {
        var resolveFunc = function ($stateParams) {
            return $stateParams[param];
        };
        resolveFunc.$inject = ['$stateParams'];

        return resolveFunc;

    }

    function resolveIntParamFactory(param) {
        var resolveFunc = function ($stateParams) {
            return parseInt($stateParams[param]);
        };
        resolveFunc.$inject = ['$stateParams'];

        return resolveFunc;

    }

    function isPositiveInteger(input) {
        return !(!input || input <= 0 || input % 1);
    }

    function objSize(obj) {
        var size = 0, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)){
                size++;
            }
        }
        return size;
    }

    function init() {
        checkBrowser();
    }

    function checkBrowser() {
        var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
        var isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+
        var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
        var isChrome = !!window.chrome && !m.isOpera;              // Chrome 1+
        var isIE = /*@cc_on!@*/false || !!document.documentMode; // At least IE6

        m.isOpera = function(){return isOpera;};
        m.isFirefox = function(){return isFirefox;};
        m.isSafari = function(){return isSafari;};
        m.isChrome = function(){return isChrome;};
        m.isIE = function(){return isIE;};
    }
}());

(function () {
angular
.module('ponysticker',[
    'ionic',
    'ngCordova',
    'pascalprecht.translate',
    'angularFileUpload',
    'ponysticker.utilites',
    'ponysticker.menu',
    'ponysticker.favorite',
    'ponysticker.local',
    'ponysticker.package',
    'ponysticker.download',
    'ponysticker.tags',
    'ponysticker.preference'
])
.config(config)
.run(run);

function config($ionicConfigProvider, $translateProvider, $urlRouterProvider) {
    $ionicConfigProvider.views.transition('none');
    $translateProvider.useLoader('$translatePartialLoader', {
        urlTemplate: 'i18n/{part}/{lang}.json'
    });

    $urlRouterProvider
    .when('/local/package', '/local/package/package')
    .when('/local/sticker', '/local/sticker/sticker')
    .when('/favorite/package', '/favorite/package/package')
    .when('/favorite/sticker', '/favorite/sticker/sticker')
    .otherwise('/local/sticker/sticker');

}

function run($rootScope, $ionicPlatform, $translate, preference, database) {
    $ionicPlatform.ready(function() {
        if (ionic.Platform.isWebView()) {
            $rootScope.intentType = 'main';
            window.PonyPlugin.checkIntent(function(res) {
                $rootScope.intentType = res;
                console.log(res);
            });
        } else {
            $rootScope.intentType = 'browser';
        }
        database.init();
    });
    $translate.use(preference.getLanguage());
}
}());

(function () {
angular
.module('ponysticker.download', [])
.config(config)
.run(run);

function config($stateProvider) {
    $stateProvider
    .state('download', {
        url: '/download/:repo',
        templateUrl: 'templates/download.html',
        controller: 'DownloadController as download',
        resolve: {
            repo: PonyModule.resolveParamFactory('repo')
        }
    });
}

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('download');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.favorite', [])
.config(config)
.run(run);

function config($stateProvider) {
    $stateProvider
    .state('favorite', {
        url: '/favorite/:type',
        templateUrl: 'templates/favorite.html',
        controller: 'FavoriteController as favorite',
        resolve: {
            type: PonyModule.resolveParamFactory('type')
        }
    })
    .state('favorite.package', {
        url: '/package',
        templateUrl: 'templates/favorite-package.html',
        controller: 'LocalPackageController as package'
    })
    .state('favorite.sticker', {
        url: '/sticker',
        templateUrl: 'templates/favorite-sticker.html',
        controller: 'LocalStickerController as stickerList'
    });
}

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('favorite');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.local', [])
.config(config)
.run(run);

function config($stateProvider) {
    $stateProvider
    .state('local', {
        url: '/local/:type',
        templateUrl: 'templates/local.html',
        controller: 'LocalController as local',
        resolve: {
            type: PonyModule.resolveParamFactory('type')
        }
    })
    .state('local.package', {
        url: '/package',
        templateUrl: 'templates/local-package.html',
        controller: 'LocalPackageController as package'
    })
    .state('local.sticker', {
        url: '/sticker',
        templateUrl: 'templates/local-sticker.html',
        controller: 'LocalStickerController as stickerList'
    });

}

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('local');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.menu', [])
.run(run);

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('menu');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.package', [])
.config(config)
.run(run);

function config($stateProvider) {
    $stateProvider
    .state('package', {
        url: '/package/:repo/:packageId',
        templateUrl: 'templates/package.html',
        controller: 'PackageController as package',
        resolve: {
            repo: PonyModule.resolveParamFactory('repo'),
            packageId: PonyModule.resolveIntParamFactory('packageId')
            
        }
    });
}

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('package');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.preference', [])
.config(config)
.run(run);

function config($stateProvider) {
    $stateProvider
    .state('preference', {
        url: '/preference',
        templateUrl: 'templates/preference.html',
        controller: 'PreferenceController as preference'
    });
}

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('preference');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.tags', [])
.config(config)
.run(run);

function config($stateProvider) {
    $stateProvider
    .state('tags', {
        url: '/tags/:type/:id',
        templateUrl: 'templates/tags.html',
        controller: 'TagsController as tags',
        resolve: {
            type: PonyModule.resolveParamFactory('type'),
            id: PonyModule.resolveIntParamFactory('id')
        }
    });
}

function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('tags');
    $translate.refresh();
}

}());

(function () {
angular
.module('ponysticker.utilites', [])
.run(run);
function run($translate, $translatePartialLoader) {
    $translatePartialLoader.addPart('utilites');
    $translate.refresh();
}
}());

(function () {
angular
.module('ponysticker.download')
.controller('DownloadController', DownloadController);

function DownloadController($scope, $state,
        $ionicScrollDelegate, $ionicPopup, $ionicPopover,
        $translate, preference, serverAPI, database, repo) {
    var self = this;
    self.repo = repo;
    self.order = preference.getOrder();
    self.pkgCount = 0;
    self.page = 1;
    self.pkgList = [];
    self.pkgTabList = [];
    self.query = '';

    self.getPageCount = getPageCount;
    self.search = search;
    self.getTitle = getTitle;
    self.getAuthor = getAuthor;
    self.goPrev = goPrev;
    self.goNext = goNext;
    self.searchInField = searchInField;
    self.showPageEditor = showPageEditor;
    self.showSortPopover = showSortPopover;
    self.refreshAll = refreshAll;
    self.isLoading = isLoading;
    self.isLoadingErr = isLoadingErr;

    init();

    function isLoading () {
        return self.isListLoading || self.isCountLoading;
    }

    function isLoadingErr() {
        return self.loadingListErr || self.loadingCountErr;
    }

    function showSortPopover($event) {
        self.sortPopover.show($event);
    }

    function showPageEditor() {
        self.pageEditor = {
            newPage: self.page,
            isPositiveInteger: isPositiveInteger,
            isInRange: isInRange,
            applyNewPage: applyNewPage
        };

        $translate([
            'DOWNLOAD_PAGE_TITLE',
            'DOWNLOAD_PAGE_ALERT',
            'DOWNLOAD_CANCEL',
            'DOWNLOAD_OK'])
        .then(showPopup);

        function showPopup(trans) {
            var popup = $ionicPopup.show({
                title: trans.DOWNLOAD_PAGE_TITLE,
                templateUrl: 'templates/download-page-editor.html',
                scope: $scope,
                buttons: [
                    {text: trans.DOWNLOAD_CANCEL},
                    {
                        text: trans.DOWNLOAD_OK,
                        type: 'button-positive',
                        onTap: function(e) {
                            if (!isLegal()) {
                                e.preventDefault();
                            } else {
                                return true;
                            }
                        }
                    }
                ]

            });
            popup.then(function(res) {
                if (res) {
                    applyNewPage();
                }
            }); 

            self.pageEditor.closeInField = function($event) {
                if ($event.keyCode === 13 && isLegal()) {
                    applyNewPage();
                    popup.close();
                }
            };
        }

        function isPositiveInteger() {
            return PonyModule.isPositiveInteger(self.pageEditor.newPage);
        }

        function isInRange() {
            return self.pageEditor.newPage < self.getPageCount();
        }

        function isLegal() {
            return isPositiveInteger() && isInRange();
        }

        function applyNewPage() {
            self.page = self.pageEditor.newPage;
            refreshPkgList();
        }

    }

    function getPageCount() {
        return Math.ceil(self.pkgCount / preference.getPageSize());
    }

    function search() {
        self.page = 1;
        refreshPkgCount();
        refreshPkgList();
    }

    function searchInField($event) {
        if ($event.keyCode === 13) {
            search();
        }
    }

    function getTitle(pkg) {
        var title = pkg.title[preference.getLanguage()];
        if (!title) {
            title = pkg.title['en'];
        }
        
        return title;
    }

    function getAuthor(pkg) {
        var author = pkg.author[preference.getLanguage()];
        if (!author) {
            author = pkg.author['en'];
        }
        
        return author;
    }

    function goPrev() {
        self.page -= 1;
        if (self.page <= 0) {
            self.page = getPageCount();
        }

        refreshPkgList();
    }

    function goNext() {
        self.page += 1;
        if (self.page > getPageCount()) {
            self.page = 1;
        }
        refreshPkgList();
    }

    function init() {
        refreshAll();
        buildSortPopover();
        watchOrder();
        $scope.$on('$ionicView.enter', enterCheck);
    }

    function enterCheck() {
        checkPkgDownloaded();
    }

    function buildSortPopover() {
        $ionicPopover.fromTemplateUrl(
            'templates/download-sort-popover.html', {
            scope: $scope,
        }).then(function(popover) {
            self.sortPopover = popover;
        });
    }

    function watchOrder() {
        $scope.$watch(function() {
            return self.order;
        }, function(value) {
            preference.setOrder(value);
            self.page = 1;
            refreshPkgList();
        });
    }

    function refreshPkgList() {
        self.pkgList = [];
        self.pkgTabList = [];
        self.isListLoading = true;
        serverAPI
        .getPkgList(self.repo, self.page,
                    preference.getPageSize(),
                    self.order,
                    self.query)
        .success(function(data) {
            self.isListLoading = false;
            self.loadingListErr = false;
            self.pkgList = data;
            checkPkgDownloaded();
            $ionicScrollDelegate.scrollTop();
        })
        .error(function() {
            self.isListLoading = false;
            self.loadingListErr = true;
        });
    }

    function checkPkgDownloaded() {
        self.pkgList.forEach(function(pkg, idx) {
            database
            .getMeta('package', pkg.packageId)
            .success(function(meta) {
                if (meta) {
                    self.pkgTabList[idx] = 
                        serverAPI.getTabOffUrl(pkg.packageId);
                } else {
                    self.pkgTabList[idx] =
                        serverAPI.getTabOnUrl(pkg.packageId);
                }
            })
            .error(function() {
                self.pkgTabList[idx] =
                    serverAPI.getTabOnUrl(pkg.packageId);
            });
        });
    }

    function refreshPkgCount() {
        self.isCountLoading = true;
        serverAPI
        .getPkgCount(self.repo, self.query)
        .success(function(data) {
            self.isCountLoading = false;
            self.loadingCountErr = false;
            self.pkgCount = data;
        })
        .error(function() {
            self.isCountLoading = false;
            self.loadingCountErr = true;
        });
    }

    function refreshAll() {
        refreshPkgCount();
        refreshPkgList();
    }
}
}());

(function () {
angular
.module('ponysticker.download')
.service('serverAPI', serverAPI);

function serverAPI($http, preference) {
    var self = this;
    
    self.getMeta = getMeta;
    self.getTabOnUrl = getTabOnUrl;
    self.getTabOffUrl = getTabOffUrl;
    self.getStickerBase64 = getStickerBase64;
    self.getPkgCount = getPkgCount;
    self.getPkgList = getPkgList;

    function getStickerBase64(pkg, sticker) {
        return $http.get(concatUrl('sticker'), {
            params: {
                pkg: pkg,
                sticker: sticker,
                base64: '1'
            }
        });
    }

    function getMeta(repo, pkg) {
        return $http.get(concatUrl('meta'), {
            params: {
                repo: repo,
                pkg: pkg
            }
        });
    }

    function getTabOnUrl(pkg) {
        return concatUrl('sticker') + '?' + $.param([
            {name: 'pkg', value: pkg},
            {name: 'sticker', value: 'tab_on'}]);
    }

    function getTabOffUrl(pkg) {
        return concatUrl('sticker') + '?' + $.param([
            {name: 'pkg', value: pkg},
            {name: 'sticker', value: 'tab_off'}]);
    }

    function getStickerKeyUrl(pkg, sticker) {
        return concatUrl('sticker') + '?' + $.param([
            {name: 'pkg', value: pkg},
            {name: 'sticker', value: sticker+'_key'}
        ]);
    }

    function getPkgCount(repo, query) {
        return $http.get(concatUrl('pkg-count'), {
            params: {
                repo: repo,
                q: query
            }
        });
    }

    function getPkgList(repo, page, size, order, query) {
        return $http.get(concatUrl('pkg-list'), {
            params: {
                repo: repo,
                page: page,
                size: size,
                order: order,
                q: query
            }
        });
    }

    function concatUrl(concat) {
        var url = preference.getServer();
        if (url.slice(-1) !== '/') {
            return url + '/' + concat;
        } else {
            return url + concat;
        }
    }
}

}());

(function () {
angular
.module('ponysticker.favorite')
.controller('FavoriteController', FavoriteController);

function FavoriteController($scope, database, preference, type) {
    var self = this;

    self.page = 1;
    self.pageSize = preference.getPageSize();
    self.type = type;
    self.items = [];
    self.itemImgs = {};

    self.getItemImgUrl = getItemImgUrl;

    init();

    function getItemImgUrl(itemId) {
        if (!self.itemImgs[itemId]) {
            return '';
        }
        return 'data:image/jpg;base64,'+self.itemImgs[itemId];
    }

    function init() {
        refreshItems();
        $scope.$on('$ionicView.enter', enterCheck);
    }

    function enterCheck() {
        refreshItems();
    }

    function refreshItems() {
        database
        .getMetaPaginationByStar(self.type, self.page, self.pageSize)
        .success(function(res) {
            self.items = res;
            refreshItemImgs();
        })
        .error(function() {
            //TODO
        });
    }

    function refreshItemImgs() {
        var idName;
        if (self.type === 'package') {
            idName = 'packageId';
        } else {
            idName = 'id';
        }
        self.items.forEach(function(item, index) {
            database
            .getImg(self.type, item[idName])
            .success(function(img) {
                self.itemImgs[item[idName]] = img.base64;
            })
            .error(function() {
                //TODO
            });
        });
    }

}
}());

(function () {
angular
.module('ponysticker.local')
.controller('LocalController', LocalController);

function LocalController($scope, $timeout, $ionicModal, $ionicScrollDelegate, preference, database, type) {
    var self = this;
    self.type = type;
    self.selected = {};
    self.unselected = {};
    self.page = 1;
    self.hasNext = false;
    self.pageSize = preference.getPageSize();

    self.query = '';
    self.items = [];
    self.itemImgs = {};

    self.showTagModal = showTagModal;
    self.addTag = addTag;
    self.deleteTag = deleteTag;
    self.clearTags = clearTags;
    self.getKeys = getKeys;
    self.getItemId = getItemId;
    self.getItemImgUrl = getItemImgUrl;
    self.loadMore = loadMore;
    
    init();

    function loadMore() {
        database
        .getMetasPagination(self.type, self.page+1, self.pageSize)
        .success(function(res) {
            var skip = self.items.length;
            self.items =self.items.concat(res[0]);
            refreshItemImgs(skip);
            self.hasNext = res[1];
            self.page += 1;

            $timeout(function() {
                $scope.$broadcast('scroll.infiniteScrollComplete');
            }, 100);
        })
        .error(function() {
            //TODO
        });
    }

    function getItemImgUrl(itemId) {
        if (!self.itemImgs[itemId]) {
            return '';
        }
        return 'data:image/jpg;base64,'+self.itemImgs[itemId];
    }


    function getItemId(item) {
        if (self.type === 'package') {
            return item.packageId;
        } else {
            return item.id;
        }
    }
    function clearTags() {
        for (var key in self.selected) {
            if (self.selected.hasOwnProperty(key)) {
                self.unselected[key] = true;
                delete self.selected[key];
            }
        }
    }

    function addTag(tag) {
        self.selected[tag] = true;
        delete self.unselected[tag];
        refreshItems(true);
        $ionicScrollDelegate
        .$getByHandle('modalContent')
        .scrollTop(true);
    }

    function deleteTag(tag) {
        self.unselected[tag] = true;
        delete self.selected[tag];
        refreshItems(true);
    }

    function showTagModal() {
        self.tagModal.show();
    }

    function getKeys(obj) {
        return Object.keys(obj);
    }

    function init() {
        buildModal();
        $scope.$on('$ionicView.enter', enterCheck);
    }

    function enterCheck() {
        refreshItems(true);
    }

    function refreshItems(tag) {
        $ionicScrollDelegate
        .$getByHandle('mainContent')
        .scrollTop(true);
        if ($.isEmptyObject(self.selected)) {
            database
            .getMetasPagination(self.type, 1, self.page*self.pageSize)
            .success(function(res) {
                self.items = res[0];
                self.hasNext = res[1];
                refreshItemImgs(0);
                if (tag) {
                    refreshTags();
                }
            })
            .error(function(e) {
                //TODO
            });
        } else {
            database
            .getMetasWithTags(self.type, self.selected)
            .success(function(res) {
                self.items = res;
                self.hasNext = false;
                refreshItemImgs(0);
                if (tag) {
                    refreshTags();
                }
            })
            .error(function() {
                //TODO
            });
        }
    }

    function refreshItemImgs(skip) {
        var idName;
        if (self.type === 'package') {
            idName = 'packageId';
        } else {
            idName = 'id';
        }

        self.items.slice(skip).forEach(function(item, index) {
            database
            .getImg(self.type, item[idName])
            .success(function(img) {
                self.itemImgs[item[idName]] = img.base64;
            })
            .error(function() {
                //TODO
            });
        });
    }

    function refreshTags() {
        if ($.isEmptyObject(self.selected)) {
            getUnselected();
        } else {
            var ids = self.items.map(function(item) {
                if (self.type === 'package') {
                    return item.packageId;
                } else {
                    return item.id;
                }
            });
            database
            .getTagsWithIds(self.type, ids, self.selected)
            .success(function(res) {
                self.unselected = res;
            })
            .error(function() {
                //TODO
            });
        }
    }

    function buildModal() {
        $ionicModal.fromTemplateUrl('templates/local-tags.html', {
            scope: $scope,
            animation: 'slide-in-up'
        }).then(function(modal) {
            self.tagModal = modal;
        });
    }

    function getUnselected() {
        database
        .getAllTags(self.type, [])
        .success(function(tags) {
            self.unselected = tags;
        })
        .error(function(e) {
            //TODO
        });
    }
}
}());

(function () {
angular
.module('ponysticker.local')
.controller('LocalPackageController', LocalPackageController);

function LocalPackageController(preference) {
    var self = this;

    self.getTitle = getTitle;
    self.getAuthor = getAuthor;

    function getTitle(pkg) {
        return pkg.title[preference.getLanguage()] ||
            pkg.title['en'];
    }

    function getAuthor(pkg) {
        return pkg.author[preference.getLanguage()] ||
            pkg.title['en'];
    }
}
}());

(function () {
angular
.module('ponysticker.local')
.controller('LocalStickerController', LocalStickerController);

function LocalStickerController(stickerActionSheet) {
    var self = this;

    self.showActionSheet = showActionSheet;

    function showActionSheet(sticker, imgBase64) {
        stickerActionSheet(sticker.id, true, imgBase64);
    }
}
}());

(function () {
angular
.module('ponysticker.menu')
.controller('MenuController', MenuController);

function MenuController() {
    var self = this;

    self.submenu = '';
    self.toggleSubmenu = toggleSubmenu;
    self.showSubmenu = showSubmenu;
    self.exitApp = exitApp;
    self.isWebView = ionic.Platform.isWebView;

    function exitApp() {
        window.close();
        ionic.Platform.exitApp();
    }

    function toggleSubmenu(submenu) {
        if (self.submenu !== submenu) {
            self.submenu = submenu;
        } else {
            self.submenu = '';
        }
    }

    function showSubmenu(submenu) {
        return self.submenu === submenu;
    }

}
}());

(function () {
angular
.module('ponysticker.package')
.controller('PackageController', PackageController);

function PackageController($scope, $timeout, $ionicPopup, $ionicPopover, $state, 
                           $translate, stickerActionSheet, preference, serverAPI, database, repo, packageId) {
    var self = this;
    var prefixDataURI = 'data:image/jpg;base64,';
    self.repo = repo;
    self.packageId = packageId;
    self.remote = false;
    self.favorite = false;
    self.stickersBase64 = {};
    self.isShowAll = false;
    self.hasError = false;
    self.stickers = [];
    self.stickerIdx = 0;
    self.hasMore = true;

    self.getTabOnUrl = getTabOnUrl;
    self.getStickerUrl = getStickerUrl;
    self.getTitle = getTitle;
    self.getAuthor = getAuthor;
    self.showAll = showAll;
    self.download = download;
    self.progress = progress;
    self.addFavorite = addFavorite;
    self.removeFavorite = removeFavorite;
    self.deletePackage = deletePackage;
    self.showMorePopover = showMorePopover;
    self.showActionSheet = showActionSheet;

    init();

    function showActionSheet(sticker) {
        stickerActionSheet(sticker, false, self.stickersBase64[sticker], self.remote);
    }


    function showMorePopover($event) {
        self.morePopover.show($event);
    }

    function deletePackage() {
        $translate([
            'PACKAGE_DELETE_TITLE',
            'PACKAGE_DELETE_CONTENT',
            'PACKAGE_DELETE_CANCEL',
            'PACKAGE_DELETE_CONFIRM'])
        .then(checkDelete);

        function checkDelete(trans) {
            $ionicPopup.confirm({
                title: trans.PACKAGE_DELETE_TITLE,
                template: trans.PACKAGE_DELETE_CONTENT,
                cancelText: trans.PACKAGE_DELETE_CANCEL,
                okText: trans.PACKAGE_DELETE_CONFIRM,
                okType: 'button-assertive'
            })
            .then(function(res) {
                if (res) {
                    database
                    .deletePackage(self.packageId)
                    .success(function() {
                        self.remote = true;
                        self.favorite = false;
                    })
                    .error(function() {
                        //TODO
                    });
                }
            });
        }
    }

    function addFavorite() {
        self.meta.star = 1;
        database
        .updateMeta('package', self.meta)
        .success(function() {
            self.favorite = true;
        })
        .error(function() {
            //TODO
        });
    }

    function removeFavorite() {
        self.meta.star = 0;
        database
        .updateMeta('package', self.meta)
        .success(function() {
            self.favorite = false;
        })
        .error(function() {
            //TODO
        });
        
    }

    function progress() {
        var v = 0;
        if (self.tabOnBase64) {
            v += 1;
        }

        return v + PonyModule.objSize(self.stickersBase64);
    }

    function showAll() {
        self.isShowAll = true;
    }

    function download() {
        self.isDownloading = true;
        checkDownload();
        
        function checkDownload() {
            $timeout(function() {
                if (progress() < self.meta.stickers.length + 1) {
                    checkDownload();
                } else {
                    database
                    .addPackage(self.meta, self.tabOnBase64, self.stickersBase64)
                    .success(function() {
                        self.isDownloading = false;
                        self.remote = false;
                    })
                    .error(function() {
                        //TODO
                    });
                }
            }, 500);
        }
    }

    function getStickerUrl(sticker) {
        if (!self.stickersBase64[sticker]) {
            return '';
        }
        return prefixDataURI+self.stickersBase64[sticker];
    }

    function getTitle() {
        if (!self.meta) {
            return '';
        } 
        var title = self.meta.title[preference.getLanguage()];
        if (!title) {
            title = self.meta.title['en'];
        }
        
        return title;
    }

    function getAuthor() {
        if (!self.meta) {
            return '';  
        } 
        var author = self.meta.author[preference.getLanguage()];
        if (!author) {
            author = self.meta.author['en'];
        }
        
        return author;
    }

    function getTabOnUrl() {
        if (!self.tabOnBase64) {
            return '';
        }
        return prefixDataURI+self.tabOnBase64;
    }
    
    function init() {
        buildMorePopover();

        database
        .getMeta('package', self.packageId)
        .success(function(meta) {
            self.meta = meta;
            if (!self.meta) {
                self.remote = true;
                initFromRemote();
            } else {
                self.remote =false;
                self.favorite = self.meta.star;
                getStickersBase64();
                getTabOnBase64();
            }
        })
        .error(function(e) {
            //TODO
        });
    }

    function getTabOnBase64() {
        database
        .getImg('package', self.packageId)
        .success(function(img) {
            self.tabOnBase64 = img.base64;
        })
        .error(function() {
            //TODO
        });
    }

    function buildMorePopover() {
        self.morePopover = $ionicPopover.fromTemplateUrl(
            'templates/package-more-popover.html', {
            scope: $scope,
        }).then(function(popover) {
            self.morePopover = popover;
        });
    }

    function getStickersBase64() {
        self.meta.stickers.forEach(function(sticker) {
            database
            .getImg('sticker', sticker)
            .success(function(img) {
                self.stickersBase64[sticker] = img.base64;
            })
            .error(function() {
                //TODO
            });
        });
    }

    function initFromRemote() {
       serverAPI
       .getMeta(repo, packageId) 
       .success(function(data) {
           self.meta = data;
           getTabOnBase64Remote();
           getStickersBase64Remote();

       })
       .error(function() {
          self.hasError = true; 
       });
    }

    function getTabOnBase64Remote() {
        serverAPI
        .getStickerBase64(self.packageId, 'tab_on')
        .success(function(data) {
            self.tabOnBase64 = data;
        })
        .error(function() {
            self.tabOnBase64 = 0;
            self.hasError = true;
            
        });
    }

    function getStickersBase64Remote() {
        self.meta.stickers.forEach(function(sticker) {
            serverAPI
            .getStickerBase64(self.packageId, sticker)
            .success(function(data) {
                self.stickersBase64[sticker] = data;
            })
            .error(function() {
                self.stickersBase64[sticker] = 0;
                self.hasError = true;
                
            });
        });
    }
}
}());

(function () {
angular
.module('ponysticker.preference')
.service('backup', backup);

function backup($q, $timeout, $ionicLoading, database, serverAPI) {
    var self = this;

    self.importData = importData;
    self.exportData = exportData;

    function exportData($scope) {
        var deferred = $q.defer();
        var data = {};
        data.version = 2;
        var transaction = database.db.transaction([
            'package', 'sticker',
            'packageTag', 'stickerTag']);

        var pkgObjStore = transaction.objectStore('package');
        var stickerObjStore = transaction.objectStore('sticker');
        var pkgTagObjStore = transaction.objectStore('packageTag');
        var stickerTagObjStore = transaction.objectStore('stickerTag');

        $scope.loading.complete = 0;
        var countReq = pkgObjStore.count();
        countReq.onsuccess = function(e) {
            $scope.loading.total = e.target.result;
        };

        var countStickerReq = stickerObjStore.count();
        countStickerReq.onsuccess = function(e) {
            $scope.loading.stickerTotal = e.target.result;
        };

        data.package = [];
        var pkgCursor = pkgObjStore.openCursor();
        pkgCursor.onsuccess = function(e) {
            var cursor = e.target.result;
            if (cursor) {
                var meta = cursor.value;
                meta.tag = [];
                var idRange = window.IDBKeyRange.only(meta.packageId);
                var pkgTagCursor = pkgTagObjStore
                .index('id')
                .openCursor(idRange);
                pkgTagCursor.onsuccess = function(e) {
                    var tagCursor = e.target.result;
                    if (tagCursor) {
                        meta.tag.push(tagCursor.value.tag);
                        tagCursor.continue();
                    } else {
                        data.package.push(meta);
                        $scope.loading.complete += 1;
                        cursor.continue();
                    }
                };
            } else {
                processStickers();
            }
        };

        function processStickers() {
            $scope.loading.stickerComplete = 0;
            data.sticker = [];
            var stickerCursor = stickerObjStore.openCursor();
            stickerCursor.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    var meta = cursor.value;
                    meta.tag = [];
                    var idRange = window.IDBKeyRange.only(meta.id);
                    var stickerTagCursor = stickerTagObjStore
                    .index('id')
                    .openCursor(idRange);
                    stickerTagCursor.onsuccess = function(e) {
                        var tagCursor = e.target.result;
                        if (tagCursor) {
                            meta.tag.push(tagCursor.value.tag);
                            tagCursor.continue();
                        } else {
                            $scope.loading.stickerComplete += 1;
                            data.sticker.push(meta);
                            cursor.continue();
                        }
                    };
                }
            };
        }

        transaction.oncomplete = function() {
            deferred.resolve(data);
        };
        
        transaction.onerror = function(e) {
            deferred.reject(e);
        };

        return deferred.promise;
    }

    function importData(data, $scope) {
        var deferred = $q.defer();
        var version = data.version;
        var next = true;
        var hasError = false;
        $scope.loading.complete = 0;
        $scope.loading.total = data.package.length;
        if (!version) {
            version = 1;
        }


        data.package.forEach(function(pkg, index) {
            checkNext(processPackage, [pkg, index]);
        });
        
        return deferred.promise;

        function checkNext(fn, args) {
            $timeout(function() {
                if (next) {
                    fn.apply(this, args);
                } else {
                    checkNext(fn, args);
                }
            }, 1);
        }
        
        function processPackage(pkg, index) {
            if (version === 1 &&
                pkg.packageId >= 5000000) {
                $scope.loading.complete += 1;
                return;
            }
            next = false;
            var meta = null;
            var tabOnBase64 = null;
            var stickersBase64 = {};
            var stickersCount = 0;
            var repo = checkRepo(pkg.packageId);
            var error = false;
            
            checkLocal();


            function checkLocal() {
                database
                .getMeta('package', pkg.packageId)
                .success(function(data) {
                    if (!data) {
                        getDataRemote();
                        waitDonwloading();
                    } else {
                        meta = data;
                        updateMeta();
                    }
                })
                .error(function() {
                    error = true;
                    completePackage();
                    //TODO
                });
            }

            function updateMeta() {
                meta.star = pkg.star;
                database
                .updateMeta('package', meta)
                .success(function() {
                    completePackage();
                })
                .error(function() {
                    error = true;
                    completePackage();
                    //TODO
                });
            }


            function getDataRemote() {
                serverAPI
                .getMeta(repo, pkg.packageId)
                .success(function(data) {
                    meta = data;
                    getTabOnBase64Remote();
                    getStickersBase64Remote();
                })
                .error(function() {
                    error = true;
                    //TODO
                });
            }

            function getTabOnBase64Remote() {
                serverAPI
                .getStickerBase64(pkg.packageId, 'tab_on')
                .success(function(data) {
                    tabOnBase64 = data;
                })
                .error(function() {
                    error = true;
                    //TODO
                });
            }

            function getStickersBase64Remote() {
                meta.stickers.forEach(function(sticker) {
                    serverAPI
                    .getStickerBase64(pkg.packageId, sticker)
                    .success(function(data) {
                        stickersBase64[sticker] = data;
                        stickersCount += 1;
                    })
                    .error(function() {
                        error = true;
                        //TODO
                    });
                });
            }

            function waitDonwloading() {
                $timeout(function() {
                    if (meta && tabOnBase64 &&
                            stickersCount === meta.stickers.length) {
                        meta.star = pkg.star;
                        addPackage();
                    } else if (error) {
                        completePackage();
                    } else {
                        waitDonwloading();
                    }
                }, 1);
            }

            function addPackage() {
                database
                .addPackage(meta, tabOnBase64, stickersBase64)
                .success(function() {
                    completePackage();
                })
                .error(function() {
                    error = true;
                    completePackage();
                    //TODO
                });
            }

            function completePackage() {
                next = true;
                hasError = error;
                if (++$scope.loading.complete === data.package.length) {
                    processStickers();
                }
            }
        }

        function processStickers() {
            $scope.loading.stickerComplete = 0;
            $scope.loading.stickerTotal = data.sticker.length;
            data.sticker.forEach(function(sticker) {
                processSticker(sticker);
            });
        }

        function processSticker(sticker) {
            var error = false;
            var meta = null;
            var tags = null;
            getMeta();

            function getMeta() {
                database
                .getMeta('sticker', sticker.id)
                .success(function(data) {
                    if (data) {
                        meta = data;
                        getTags();
                    } else {
                        completeSticker();
                    }
                })
                .error(function() {
                    error = true;
                    completeSticker();
                    //TODO
                });
            }

            function getTags() {
                database
                .getTagsWithIds('sticker', [sticker.id], [])
                .success(function(data) {
                    tags = data;
                    updateMeta();
                })
                .error(function() {
                    error = true;
                    completeSticker();
                    //TODO
                });
            }

            function updateMeta() {
                meta.recent = sticker.recent || sticker.time;
                meta.star = sticker.star;
                database
                .updateMeta('sticker', meta)
                .success(function() {
                    updateTags();
                })
                .error(function() {
                    error = true;
                    completeSticker();
                    //TODO
                });
            }

            function updateTags() {
                sticker.tags = [];
                if (sticker.tag) {
                    sticker.tags = sticker.tag.split(' ');
                } else {
                    completeSticker();
                }
                var totalTag = sticker.tags.length;
                var tagCount = 0;
                sticker.tags.forEach(function(tag) {
                    if (!tags[tag]) {
                        database
                        .addTag(tag, 'sticker', sticker.id)
                        .success(function() {
                            if (++tagCount === totalTag) {
                                completeSticker();
                            }
                        })
                        .error(function() {
                            error = true;
                            completeSticker();
                            //TODO
                        });
                    } else {
                        if (--totalTag === tagCount) {
                            completeSticker();
                        }
                    }
                });
            }

            function completeSticker() {
                if (error) {
                    hasError = error;
                }
                if(++$scope.loading.stickerComplete ===
                   $scope.loading.stickerTotal) {
                    deferred.resolve(hasError);
                }
            }
        }

        function checkRepo(id) {
            if (id < 0) {
                return 'custom';
            } else if (id < 1000000) {
                return 'official';
            } else {
                return 'creator';
            }
        }
    }
}
}());

(function () {
angular
.module('ponysticker.preference')
.service('googledrive', googledrive);

function googledrive($timeout, $http, $q, $cordovaOauth, preference) {
    var self = this;
    //var CLIENT_ID = '826702538511-4ue3qu71ujbga5qa5id8s7k76k1ssq3e.apps.googleusercontent.com';
    var CLIENT_ID = '826702538511-cgmsl0n36bekvihgl1pb7smv9hj1r5n3.apps.googleusercontent.com';
    var SCOPES = 'https://www.googleapis.com/auth/drive.appfolder';

    self.auth = auth;
    self.uploadJson = uploadJson;
    
    function auth() {
        var deferred = $q.defer();
        if (!window.gapi) {
            $.getScript('https://apis.google.com/js/client.js?onload=handleClientLoad', hasGapi);
        } else {
            hasGapi();
        }

        function hasGapi() {
            var driveToken = preference.getDriveToken();
            var authToken = {'access_token': ''};
            if (driveToken) {
                authToken = JSON.parse(driveToken);
            }
            authToken['access_token'] = authToken['access_token'] || '';
            $http.get('https://www.googleapis.com/oauth2/v1/tokeninfo', {
                params: {
                    'access_token': authToken['access_token']
                }
            })
            .success(function(data) {
                waitGapiAuthorize(function() {
                    window.gapi.auth.setToken(authToken); 
                    deferred.resolve();
                });
            })
            .error(function(data) {
                if (ionic.Platform.isWebView()) {
                    $cordovaOauth.google(CLIENT_ID, [SCOPES])
                    .then(function(result) {
                        authToken = result;
                        preference.setDriveToken(JSON.stringify(authToken));
                        waitGapiAuthorize(function() {
                            window.gapi.auth.setToken(authToken); 
                            deferred.resolve();
                        });
                    }, function(error) {
                        deferred.reject(error);
                    });
                } else {
                    waitGapiAuthorize(function() {
                        window.gapi.auth.authorize(
                            {'client_id': CLIENT_ID, 'scope': SCOPES, 'immediate': false},
                            function(authToken) {
                                preference.setDriveToken(JSON.stringify(authToken));
                                console.log('auth.authorize');
                                console.log(authToken);
                            });
                    });
                }
            });
        }

        return deferred.promise;
    }

    function waitGapiAuthorize(fn, args) {
        $timeout(function() {
            if (!window.gapi || !window.gapi.auth) {
                waitGapiAuthorize(fn, args);
            } else {
                fn(args);
            }
        }, 100);
    }

    function uploadJson(filename, data, callback) {
        if (!window.gapi) {
            $.getScript('https://apis.google.com/js/client.js?onload=handleClientLoad', hasGapi);
        } else {
            hasGapi();
        }

        function hasGapi (script, status) {
            console.log(script);
            console.log(status);
            var boundary = '-------314159265358979323846';
            var delimiter = '\r\n--' + boundary + '\r\n';
            var closeDelim = '\r\n--' + boundary + '--';

            var contentType = 'application/json';
            var metadata = {
                'title': filename,
                'mimeType': contentType
            };

            var multipartRequestBody =
                delimiter +
                'Content-Type: application/json\r\n\r\n' +
                JSON.stringify(metadata) +
                delimiter +
                'Content-Type: ' + contentType + '\r\n' +
                '\r\n' +
                JSON.stringify(data) +
                closeDelim;

            waitGapiClient(sendRequest);

            function sendRequest() {
                var request = window.gapi.client.request({
                    'path': '/upload/drive/v2/files',
                    'method': 'POST',
                    'params': {'uploadType': 'multipart'},
                    'headers': {
                        'Content-Type': 'multipart/mixed; boundary="' + boundary + '"'
                    }, 'body': multipartRequestBody});

                    console.log(request);
                    if (!callback) {
                        callback = function(file) {
                            console.log(file);
                        };
                    }
                    request.execute(callback);
            }
        }

        function waitGapiClient(fn, args) {
            $timeout(function() {
                if (!window.gapi || !window.gapi.client) {
                    waitGapiClient(fn, args);
                } else {
                    fn(args);
                }
            }, 100);
        }
    }
}
}());

(function () {
angular
.module('ponysticker.preference')
.controller('PreferenceController', PreferenceController); 

function PreferenceController($scope, $ionicPopup, $ionicLoading, $ionicHistory,
                              $translate, preference, backup, googledrive) {
    var self = this;
    self.language = preference.getLanguage();
    self.pageSize = preference.getPageSize();
    self.server = preference.getServer();
    self.uploaded = null;

    self.updateLanguage = updateLanguage;
    self.updatePageSize = updatePageSize;
    self.updateServer = updateServer;
    self.change = change;
    self.exportData = exportData;

    init();

    function exportData() {
        console.log('exportData');
        googledrive
        .auth()
        .then(function(authToken) {
            console.log(authToken);
            googledrive.uploadJson('database.json', {text: 'test', data: 'data'}, function(file) {
                console.log('upload success');
                console.log(file);
            });
        }, function(error) {
            //TODO
        });


        //$scope.loading = {};
        //$ionicLoading.show({
            //scope: $scope,
            //templateUrl: 'templates/loading.html'
        //});
        //backup.exportData($scope)
        //.then(function(data) {
            ////$scope.downloadUrl = 'data:application/octet-stream;charset=utf-8,'+
                ////encodeURIComponent(JSON.stringify(data));
            ////window.open($scope.downloadUrl, 'database.json');
            ////window.open('data:text/plain;base64,'+data,'_blank');
            ////PonyModule.saveData(data, 'database.json');
            //$ionicLoading.hide();
        //}, function() {
            //$ionicLoading.hide();
            //$translate([
                //'PREFERENCE_IMPORT_ALERT_TITLE',
                //'PREFERENCE_IMPORT_ALERT_CONTENT'
            //])
            //.then(function(trans) {
                //$ionicPopup.alert({
                    //title: trans.PREFERENCE_IMPORT_ALERT_TITLE,
                    //template: trans.PREFERENCE_IMPORT_ALERT_CONTENT
                //});
            //});
        //});
    }

    function change() {
        var reader = new FileReader();
        reader.onload = function(e) {
            var data = JSON.parse(e.target.result);

            $scope.loading = {};
            $ionicLoading.show({
                scope: $scope,
                templateUrl: 'templates/loading.html'
            });
            backup.importData(data, $scope)
            .then(function(hasError) {
                $ionicLoading.hide();
                if (hasError) {
                    $translate([
                        'PREFERENCE_IMPORT_ALERT_TITLE',
                        'PREFERENCE_IMPORT_ALERT_CONTENT'
                    ])
                    .then(function(trans) {
                        $ionicPopup.alert({
                            title: trans.PREFERENCE_IMPORT_ALERT_TITLE,
                            template: trans.PREFERENCE_IMPORT_ALERT_CONTENT
                        });
                    });
                }

            });
        };
        reader.readAsText(self.uploaded[0]);
    }

    function init() {
        getSpace();
    }

    function updateLanguage() {
        preference.setLanguage(self.language);
        $translate.use(self.language);
    }

    function updateServer() {
        preference.setServer(self.server);
    }

    function updatePageSize() {
        preference.setPageSize(self.pageSize);
        $ionicHistory.clearCache();
    }

    function getSpace() {
        if (ionic.Platform.isWebView()) {
            return;
        }
        if (navigator.webkitTemporaryStorage) {
            navigator
            .webkitTemporaryStorage
            .queryUsageAndQuota(function(used, remaining) {
                self.usedMB = parseInt(used/1024/1024);
                self.totalMB = parseInt((remaining+used)/1024/1024);
            }, function(e) {
                //TODO
            });
            return;
        }

        if (window.webkitStorageInfo) {
            window
            .webkitStorageInfo
            .queryUsageAndQuota(window.webkitStorageInfo.TEMPORAR, function(used, remaining) {
                self.usedMB = parseInt(used/1024/1024);
                self.totalMB = parseInt((remaining+used)/1024/1024);

            }, function (e) {
                //TODO
            });
            return;
        }

        if (ionic.Platform.isIOS()) {
            self.usedMB = 'unknown';
            self.totalMB = '50';
        }
        
    }
}
}());

(function () {
angular
.module('ponysticker.tags')
.controller('TagsController', TagsController);

function TagsController($ionicPopup, $translate, database, type, id) {
    var self = this;

    self.type = type;
    self.id = id;
    self.unselected = {};
    self.selected = {};
    self.query = '';

    self.addTag = addTag;
    self.deleteTag = deleteTag;
    self.addTagDirectly = addTagDirectly;
    self.addTagInField= addTagInField;
    self.getKeys = getKeys;

    init();

    function getKeys(obj) {
        return Object.keys(obj);
    }

    function addTag(tag) {
        database
        .addTag(tag, self.type, self.id)
        .success(function() {
            delete self.unselected[tag];
            self.selected[tag] = true;
        })
        .error(function() {
            //TODO
        });
    }

    function deleteTag(tag) {
        database
        .deleteTag(tag, self.type, self.id) 
        .success(function() {
            delete self.selected[tag];
            self.unselected[tag] = true;
        })
        .error(function() {
            //TODO
        });
    }

    function addTagDirectly() {
        if (!self.query ||
            self.selected[self.query]) {
            return;
        }

        database
        .addTag(self.query, self.type, self.id)
        .success(function() {
            self.selected[self.query] = true;
            delete self.unselected[self.query];
            self.query = '';
        })
        .error(function() {
            //TODO
        });
    }

    function addTagInField($event) {
        if ($event.keyCode === 13) {
            addTagDirectly();
        }
    }

    function init() {
        database
        .getClassifiedTags(self.type, self.id)
        .success(function(res) {
            self.selected = res[0];
            self.unselected = res[1];
        })
        .error(function() {
            //TODO
        });
    }

    function getSelected() {
        database
        .getMeta(self.type, self.id)
        .success(function(meta) {
            self.selected = meta.tags;
            getUnselected();
        })
        .error(function() {
            //TODO
        });
    }

    function getUnselected() {
        database
        .getFilteredTags(self.type, self.selected)
        .success(function(tags) {
            self.unselected = tags;
        })
        .error(function(e) {
            //TODO
        });
    }
}
}());

(function () {
angular
.module('ponysticker.utilites')
.directive('backgroundSrc', backgroundSrc);

function backgroundSrc() {
    return {
        restrict: 'A',
        link: function(scope, element, attrs) {
            attrs.$observe('backgroundSrc', function(url) {
                element.css({
                    'background-image': 'url("'+url+'")'
                });
            });
        }
    };
}
}());

(function () {
angular
.module('ponysticker.utilites')
.service('database', database);

function database($q, $timeout) {
    var self = this;
    var pkgObjStoreReady = false;
    var stickerObjStoreReady = false;
    var pkgTagObjStoreReady = false;
    var stickerTagObjStoreReady = false;
    var pkgImgObjStoreReady = false;
    var stickerImgObjStoreReady = false;
    var indexedDB = null;
    var IDBKeyRange = null;
    self.dbVersion = 1;

    self.init = init;
    self.addPackage = addPackage;
    self.deletePackage = deletePackage;
    self.updateMeta = updateMeta;
    self.getMeta = getMeta;
    self.addTag = addTag;
    self.deleteTag = deleteTag;
    self.getClassifiedTags = getClassifiedTags;
    self.getAllTags = getAllTags;
    self.getTagsWithIds = getTagsWithIds;
    self.getMetasPagination = getMetasPagination;
    self.getMetasWithTags = getMetasWithTags;
    self.getMetaPaginationByStar = getMetaPaginationByStar;
    self.getImg = getImg;

    function getMetaPaginationByStar(type) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var starRange = IDBKeyRange.only(1);
            var cursorReq;
                cursorReq = self.db
                .transaction([type], 'readonly')
                .objectStore(type)
                .index('star')
                .openCursor(starRange);

            cursorReq.onerror = function(e) {
                deferred.reject(e);
            };

            var items = [];

            cursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    items.push(cursor.value);
                    cursor.continue();
                } else {
                    deferred.resolve(items);
                }
            };
        });
        return buildPromise(deferred.promise);

    }

    function getMetasWithTags(type, tags) {
        var deferred = $q.defer();
        var tagsKey = Object.keys(tags);
        checkReadyBeforeWait(function() {
            var tagTransaction = self.db.transaction([type+'Tag'], 'readonly');
            var tagObjStore = tagTransaction.objectStore(type+'Tag');

            var tagsIds = [];
            tagsKey.forEach(function(tagKey, index) {
                tagsIds[index] = {};
                var tagRange = IDBKeyRange.only(tagKey);
                var cursorReq = tagObjStore.index('tag').openCursor(tagRange);
                cursorReq.onsuccess = function(e) {
                    var cursor = e.target.result;
                    if (cursor) {
                        tagsIds[index][cursor.value.id] = true;
                        cursor.continue();
                    }
                };
            });

            tagTransaction.onerror = function(e) {
                deferred.reject(e);
            };

            tagTransaction.oncomplete = function(e) {
                var prev = tagsIds[0];
                for (var idx = 1; idx < tagsIds.length; idx+=1) {
                    prev = PonyModule.objIntersection(prev, tagsIds[idx]);
                }
                var transaction = self.db.transaction([type], 'readonly');
                var objStore = transaction.objectStore(type);

                var metas = [];
                for (var key in prev) {
                    if (prev.hasOwnProperty(key)) {
                        var id = parseInt(key);
                        objStore.get(id).onsuccess = function(e) {
                            metas.push(e.target.result);
                        };
                    }
                }

                transaction.onerror = function(e) {
                    deferred.reject(e);
                };

                transaction.oncomplete = function(e) {
                    deferred.resolve(metas);
                };
            };
        });
        return buildPromise(deferred.promise);
    }

    function getMetasPagination(type, page, size) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var cursorReq;
            if (type === 'sticker'){
                cursorReq = self.db
                .transaction(['sticker'], 'readonly')
                .objectStore('sticker')
                .index('recent')
                .openCursor(null, 'prev');
            } else {
                cursorReq = self.db
                .transaction([type], 'readonly')
                .objectStore(type)
                .openCursor();
            }

            cursorReq.onerror = function(e) {
                deferred.reject(e);
            };

            var count = 0;
            var items = [];
            var advancing = true;
            var hasNext = true;

            cursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (advancing) {
                        if (page === 1) {
                            items.push(cursor.value);
                            count += 1;
                            cursor.continue();
                        } else {
                            cursor.advance((page-1)*size);
                        }
                        advancing = false;
                    } else {
                        if (count < size) {
                            items.push(cursor.value);
                            count += 1;
                            cursor.continue();
                        } else {
                            deferred.resolve([items, hasNext]);
                        }
                    }
                } else {
                    hasNext = false;
                    deferred.resolve([items, hasNext]);
                }
            };
        });
        return buildPromise(deferred.promise);
    }

    function getTagsWithIds(type, ids, excludes) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var tagTransaction = self.db.transaction([type+'Tag'], 'readonly');
            var tagObjStore = tagTransaction.objectStore(type+'Tag');

            var idsTags = [];
            ids.forEach(function(id, index) {
                idsTags[index] = {};
                var idRange = IDBKeyRange.only(id);
                var cursorReq = tagObjStore.index('id').openCursor(idRange);
                cursorReq.onsuccess = function(e) {
                    var cursor = e.target.result;
                    if (cursor) {
                        var tag = cursor.value.tag;
                        if (!excludes[tag]) {
                            idsTags[index][tag] = true;
                        }
                        cursor.continue();
                    }
                };
            });

            tagTransaction.onerror = function(e) {
                deferred.reject(e);
            };

            tagTransaction.oncomplete = function(e) {
                var prev = idsTags[0];
                for (var idx = 1; idx < idsTags.length; idx+=1) {
                    prev = PonyModule.objUnionInPlace(prev, idsTags[idx]);
                }

                deferred.resolve(prev);
            };
        });
        return buildPromise(deferred.promise);
    }

    function getAllTags(type) {
        var objStoreName = type+'Tag';
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var cursorReq = self.db
            .transaction([objStoreName], 'readonly')
            .objectStore(objStoreName)
            .openCursor();

            cursorReq.onerror = function(e) {
                deferred.reject(e);
            };

            var tags = {};
            cursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    tags[cursor.value.tag] = true;
                    cursor.continue();
                } else {
                    deferred.resolve(tags);
                }
            };
        });
        return buildPromise(deferred.promise);
    }

    function getClassifiedTags(type, id) {
        var objStoreName = type+'Tag';
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var cursorReq = self.db
            .transaction([objStoreName], 'readonly')
            .objectStore(objStoreName)
            .openCursor();

            cursorReq.onerror = function(e) {
                deferred.reject(e);
            };

            var selected = {};
            var unselected = {};
            cursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (cursor.value.id === id) {
                        selected[cursor.value.tag] = true;
                    } else {
                        unselected[cursor.value.tag] = true;
                    }
                    cursor.continue();
                } else {
                    for (var key in selected) {
                        if (selected.hasOwnProperty(key)) {
                            delete unselected[key];
                        }
                    }
                    deferred.resolve([selected, unselected]);
                }
            };
        });
        return buildPromise(deferred.promise);
    }

    function addTag(tag, type, id) {
        var objStoreName = type+'Tag';
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var idRange = IDBKeyRange.only(id);
            var transaction = self.db.transaction([objStoreName], 'readwrite');
            var objStore = transaction.objectStore(objStoreName);
            var cursorReq = objStore.index('id').openCursor(idRange);

            cursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (cursor.value.tag !== tag) {
                        cursor.continue();
                    }
                } else {
                    var putReq = objStore.put({tag: tag, id: id});
                }
            };

            transaction.oncomplete = function(e) {
                deferred.resolve(e);
            };

            transaction.onerror = function(e) {
                deferred.reject(e);
            };

        });
        return buildPromise(deferred.promise);
    }

    function deleteTag(tag, type, id) {
        var objStoreName = type+'Tag';
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var idKeyRange = IDBKeyRange.only(id);
            var transaction = self.db.transaction([objStoreName], 'readwrite');
            var objStore = transaction.objectStore(objStoreName);
            var cursorReq = objStore.index('id').openCursor(idKeyRange);

            cursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (cursor.value.tag === tag) {
                        var deleteReq = objStore.delete(cursor.primaryKey);
                    } else {
                        cursor.continue();
                    }
                }
            };

            transaction.oncomplete = function(e) {
                deferred.resolve(e);
            };

            transaction.onerror = function(e) {
                deferred.reject(e);
            };
        });
        return buildPromise(deferred.promise);
    }

    function deletePackage(packageId) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function(){
            var transaction =
                self.db.transaction([
                'package', 'sticker',
                'packageTag', 'stickerTag',
                'packageImg', 'stickerImg'], 'readwrite');

            var pkgObjStore = transaction.objectStore('package');
            var stickerObjStore = transaction.objectStore('sticker');
            var pkgTagObjStore = transaction.objectStore('packageTag');
            var stickerTagObjStore = transaction.objectStore('stickerTag');
            var pkgImgObjStore = transaction.objectStore('packageImg');
            var stickerImgObjStore = transaction.objectStore('stickerImg');
            var getReq = pkgObjStore.get(packageId);
            getReq.onsuccess = function(e) {
                var meta = e.target.result;
                meta.stickers.forEach(function(sticker) {
                    var stickerIdRange = IDBKeyRange.only(sticker);
                    var stickerCursorReq = stickerTagObjStore.index('id').openCursor(stickerIdRange);
                    stickerCursorReq.onsuccess = function(e) {
                        var cursor = e.target.result;
                        if (cursor) {
                            stickerTagObjStore.delete(cursor.primaryKey);
                            cursor.continue();
                        }
                    };
                    stickerImgObjStore.delete(sticker);
                    stickerObjStore.delete(sticker);
                });
            };

            var pkgIdRange = IDBKeyRange.only(packageId);
            var pkgCursorReq = pkgTagObjStore.index('id').openCursor(pkgIdRange);
            pkgCursorReq.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    pkgTagObjStore.delete(cursor.primaryKey);
                    cursor.continue();
                }
            };
            pkgImgObjStore.delete(packageId);
            pkgObjStore.delete(packageId);


            transaction.oncomplete = function(e) {
                deferred.resolve(e);
            };

            transaction.onerror = function(e) {
                deferred.reject(e);
            };

        });
        return buildPromise(deferred.promise);

    }

    function updateMeta(type, meta) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var updateReq = self.db
            .transaction(type, 'readwrite')
            .objectStore(type)
            .put(meta);

            updateReq.onsuccess = function(e) {
                deferred.resolve(e);
            };
            updateReq.onerror = function(e) {
                deferred.reject(e);
            };

        });
        
        return buildPromise(deferred.promise);
    }

    function getImg(type, id) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var getReq = self.db
            .transaction(type+'Img')
            .objectStore(type+'Img')
            .get(id);

            getReq.onsuccess = function(e) {
                deferred.resolve(e.target.result);
            };
            getReq.onerror = function(e) {
                deferred.reject(e);
            };
        });

        return buildPromise(deferred.promise);
    }

    function getMeta(type, id) {
        var deferred = $q.defer();
        checkReadyBeforeWait(function() {
            var getReq = self.db
            .transaction(type)
            .objectStore(type)
            .get(id);

            getReq.onsuccess = function(e) {
                deferred.resolve(e.target.result);
            };
            getReq.onerror = function(e) {
                deferred.reject(e);
            };
        });

        return buildPromise(deferred.promise);
    }

    function addPackage(meta, tabOnBase64, stickersBase64) {
        var deferred = $q.defer();
        checkReady(function() {
            var transaction = self.db.transaction([
                'package', 'sticker',
                'packageImg', 'stickerImg'], 'readwrite');
            var pkgObjStore = transaction.objectStore('package');
            var pkgImgObjStore = transaction.objectStore('packageImg');
            meta.date = Date.now();
            if (meta.star === undefined) {
                meta.star = 0;
            }
            pkgObjStore.add(meta);
            pkgImgObjStore.add({packageId: meta.packageId, base64: tabOnBase64});

            var stickerObjStore = transaction.objectStore('sticker');
            var stickerImgObjStore = transaction.objectStore('stickerImg');
            for (var key in stickersBase64) {
                if (stickersBase64.hasOwnProperty(key)){
                    var sticker = {
                        id: parseInt(key),
                        packageId: meta.packageId,
                        recent: 0,
                        star: 0,
                    };
                    stickerObjStore.add(sticker);
                    stickerImgObjStore.add({id: sticker.id, base64: stickersBase64[key]});
                }
            }

            transaction.oncomplete = function(e) {
                deferred.resolve(e);
            };

            transaction.onerror = function(e) {
                deferred.reject(e);
            };
        });

        return buildPromise(deferred.promise);
    }

    function checkReady(fn) {
        $timeout(function() {
            if(!isAllReady()) {
                checkReady(fn);
            } else {
                fn();
            }
        }, 200);
    }

    function checkReadyBeforeWait(fn) {
        if (isAllReady()) {
            fn();
        } else {
            checkReady(fn);
        }
    }

    function isAllReady() {
        return pkgObjStoreReady &&
            stickerObjStoreReady &&
            pkgTagObjStoreReady &&
            stickerTagObjStoreReady &&
            pkgImgObjStoreReady &&
            stickerImgObjStoreReady;
    }

    function buildPromise(promise) {
        promise.success = function(fn) {
            promise.then(function(e) {
                fn(e);
            });
            return promise;
        };

        promise.error = function(fn) {
            promise.then(null, function(e) {
                fn(e);
            });
            return promise;
        };

        return promise;
    }

    function init() {
        if (ionic.Platform.isWebView() || ionic.Platform.isIOS() || PonyModule.isSafari()) {
            window.shimIndexedDB.__useShim();
            indexedDB = window._indexedDB || window.indexedDB;
            IDBKeyRange = window._IDBKeyRange || window.IDBKeyRange;
        } else {
            indexedDB = window.indexedDB || window._indexedDB;
            IDBKeyRange = window.IDBKeyRange || window._IDBKeyRange;
        }

        if (!indexedDB) {
            //TODO
        }
        var openReq = indexedDB.open('ponyDB', self.dbVersion);
        openReq.onupgradeneeded = function(e) {
            self.db = e.target.result;
            if (e.oldVersion < 1) {
                var pkgObjStore = self.db.createObjectStore('package', {keyPath: 'packageId'});
                pkgObjStore.createIndex('date', 'date', {unique:false});
                pkgObjStore.createIndex('star', 'star', { unique: false });
                pkgObjStore.transaction.oncomplete = function(e) {
                    pkgObjStoreReady = true;
                };
                pkgObjStore.transaction.onerror = function(e) {
                    //TODO
                };

                var pkgTagObjStore = self.db.createObjectStore('packageTag', {autoIncrement: true});
                pkgTagObjStore.createIndex('tag', 'tag', {unique: false});
                pkgTagObjStore.createIndex('id', 'id', {unique: false});
                pkgTagObjStore.transaction.oncomplete = function(e) {
                    pkgTagObjStoreReady = true;
                };
                pkgTagObjStore.transaction.onerror = function(e) {
                    //TODO
                };

                var pkgImgObjStore = self.db.createObjectStore('packageImg', {keyPath: 'packageId'});
                pkgImgObjStore.transaction.oncomplete = function(e) {
                    pkgImgObjStoreReady = true;
                };
                pkgImgObjStore.transaction.onerror = function(e) {
                    //TODO
                };


                var stickerObjStore = self.db.createObjectStore('sticker', {keyPath: 'id'});
                stickerObjStore.createIndex('packageId', 'packageId', {unique: false});
                stickerObjStore.createIndex('recent', 'recent', {unique:false});
                stickerObjStore.createIndex('star', 'star', {unique:false});
                stickerObjStore.transaction.oncomplete = function(e) {
                    stickerObjStoreReady = true;
                };
                stickerObjStore.transaction.onerror = function(e) {
                    //TODO
                };

                var stickerTagObjStore = self.db.createObjectStore('stickerTag', {autoIncrement: true});
                stickerTagObjStore.createIndex('tag', 'tag', {unique: false});
                stickerTagObjStore.createIndex('id', 'id', {unique: false});
                stickerTagObjStore.transaction.oncomplete = function(e) {
                    stickerTagObjStoreReady = true;
                };
                stickerTagObjStore.transaction.onerror = function(e) {
                    //TODO
                };

                var stickerImgObjStore = self.db.createObjectStore('stickerImg', {keyPath: 'id'});
                stickerImgObjStore.transaction.oncomplete = function(e) {
                    stickerImgObjStoreReady = true;
                };
                stickerImgObjStore.transaction.onerror = function(e) {
                    //TODO
                };
            }
        }; 
        openReq.onsuccess = function(e) {
            pkgObjStoreReady = true;
            stickerObjStoreReady = true;
            pkgTagObjStoreReady = true;
            stickerTagObjStoreReady = true;
            pkgImgObjStoreReady = true;
            stickerImgObjStoreReady = true;
            self.db = e.target.result;
        };

        openReq.onerror = function() {
            //TODO
        };
    }
}
}());

(function () {
angular
.module('ponysticker.utilites')
.service('preference', preference);

function preference() {
    var self = this;

    self.setLanguage = setItemFactory('language');
    self.getLanguage = getItemFactory('language', 'en');
    self.setServer = setItemFactory('server');
    self.getServer = getItemFactory('server', 'http://1.34.244.41:50025');
    self.setPageSize = setItemFactory('pageSize');
    self.getPageSize = getItemFactory('pageSize', 12);
    self.setOrder = setItemFactory('order');
    self.getOrder = getItemFactory('order', 'packageId');
    self.setDatabaseVersion = setItemFactory('dbversion');
    self.getDatabaseVersion = getItemFactory('dbversion', 0);
    self.setDriveToken = setItemFactory('driveToken');
    self.getDriveToken = getItemFactory('driveToken', undefined);

    function setItemFactory(item) {
        return function(value) {
            localStorage.setItem(item, value);
        };
    }

    function getItemFactory(item, defaultValue) {
        return function() {
            var value = localStorage.getItem(item);
            if (!value) {
                value = defaultValue;
            }
            return value;
        };
    }
}
}());

(function () {
angular
.module('ponysticker.utilites')
.directive('slideToggle', slideToggle);
function slideToggle() {
    return {
        restrict: 'A',      
        scope:{
            isOpen: '=slideToggle'
        },  
        link: function(scope, element, attr) {
            var slideDuration = parseInt(attr.slideToggleDuration, 10) || 400;      

            scope.$watch('isOpen', function(newIsOpenVal, oldIsOpenVal){
                if(newIsOpenVal !== oldIsOpenVal){ 
                    element.stop().slideToggle(slideDuration);
                }
            });
        }
    };  
}
}());

(function () {
angular
.module('ponysticker.utilites')
.factory('stickerActionSheet', stickerActionSheet);

function stickerActionSheet($rootScope, $ionicActionSheet, $state, $translate, database) {
    return function showActionSheet(sticker, jump, imgBase64, remote) {
        $translate([
            'UTILITES_SET_TAGS',
            'UTILITES_CANCEL',
            'UTILITES_SHARE_STICKER',
            'UTILITES_ADD_FAVORITE',
            'UTILITES_REMOVE_FAVORITE',
            'UTILITES_JUMP_TO_PACKAGE'
        ])
        .then(function(trans) {
            database
            .getMeta('sticker', sticker)
            .success(function(res) {
                var meta = res;
                var buttons = [];
                buttons.push({text: trans.UTILITES_SHARE_STICKER});
                if (meta) {
                    if (meta.star) {
                        buttons.push({text: trans.UTILITES_REMOVE_FAVORITE});
                    } else {
                        buttons.push({text: trans.UTILITES_ADD_FAVORITE});
                    }
                    buttons.push({text: trans.UTILITES_SET_TAGS});
                    if (jump) {
                        buttons.push({text: trans.UTILITES_JUMP_TO_PACKAGE});
                    }
                }
                $ionicActionSheet.show({
                    buttons: buttons,
                    cancelText: trans.UTILITES_CANCEL,
                    buttonClicked: function(index) {
                        switch(index) {
                            case 0:
                                actionSheetShare(meta, imgBase64, remote);
                                break;
                            case 1:
                                actionSheetFavorite(meta);
                                break;
                            case 2:
                                actionSheetSetTags(meta);
                                break;
                            case 3:
                                actionSheetJumpToPackage(meta);
                        }
                        return true;
                    },
                });
            })
            .error(function() {
                //TODO
            });
        });
    };

    function actionSheetShare(meta, imgBase64, remote) {
        if (!remote) {
            meta.recent = Date.now();
            database
            .updateMeta('sticker', meta);
        }
        if ($rootScope.intentType === 'main') {
            window.PonyPlugin.shareWithBase64(imgBase64);
        } else if ($rootScope.intentType === 'browser') {
            window.open('data:image/jpg;base64,'+imgBase64,'_blank');
        } else {
            window.PonyPlugin.setResultWithBase64(imgBase64);
        }
    }

    function actionSheetFavorite(meta) {
        if (meta.star === 0) {
            meta.star = 1;
        } else {
            meta.star = 0;
        }
        database
        .updateMeta('sticker', meta)
        .error(function() {
            //TODO
        });
    }

    function actionSheetSetTags(meta) {
        $state.go('tags', {
            type:'sticker',
            id: meta.id});
    }

    function actionSheetJumpToPackage(meta) {
        $state.go('package', {
            repo: 'local',
            packageId: meta.packageId
        });
    }
}
}());

(function () {
angular
.module('ponysticker.utilites')
.directive('touchActive', touchActive);

function touchActive() {
    return {
        restrict: 'A',
        link: function(scope, element) {
            element.bind('touchstart', function() {
                element.addClass('touch-active');
            });

            element.bind('touchend', function() {
                element.removeClass('touch-active');
            });
        }

    };
}
}());
